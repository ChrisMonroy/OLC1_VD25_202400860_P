package analisis;

import java_cup.runtime.Symbol;
import java.util.LinkedList;
import java.util.HashMap;

import Abstracto.Instruccion;
import Simbolo.Tipo;
import Simbolo.Datos;
import Errores.Errores;

import Instruccion.Print;
import Instruccion.Declaracion;
import Instruccion.Asignacion;
import Instruccion.If;
import Instruccion.While;
import Instruccion.Do_While;
import Instruccion.For;
import Instruccion.Break;
import Instruccion.Continue;
import Instruccion.Switch;
import Instruccion.SwitchCaso;
import Instruccion.Incremento;
import Instruccion.Metodo;
import Instruccion.Start;
import Instruccion.Llamada;
import Instruccion.Return;
import Instruccion.Funcion;
import Instruccion.DeclaracionVector;

import Expresiones.Nativo;
import Expresiones.Aritmetica;
import Expresiones.OperadoresAritmeticos;
import Expresiones.Relacionales;
import Expresiones.OperadoresRelacionales;
import Expresiones.Logicas;
import Expresiones.OperadoresLogicos;
import Expresiones.Casteo;
import Expresiones.AccesoVar;
import Expresiones.ToString;
import Expresiones.Round;
import Expresiones.AccesoVector;
import Expresiones.AsignacionVector;
import Expresiones.InicializadorVector;
import Expresiones.AccesoVector2D;
import Expresiones.AsignacionVector2D;
import Expresiones.DeclaracionLista;
import Expresiones.Remove;
import Expresiones.Append;
import Expresiones.Find;
import Expresiones.Length;


parser code {: 
  public LinkedList listaErrores = new LinkedList();
  scanner s;
  parser(scanner s) { this.s = s; }

  public void syntax_error(Symbol s) {
    listaErrores.add(new Errores("SINTACTICO", "No se esperaba: " + s.value, s.left + 1, s.right + 1));
  }

  public void unrecovered_syntax_error(Symbol s) {
    listaErrores.add(new Errores("SINTACTICO", "Error no recuperable con: " + s.value, s.left + 1, s.right + 1));
  }

  public LinkedList extraerValores(LinkedList listaCases) {
    LinkedList vals = new LinkedList();
    if (listaCases == null) return vals;
    for (Object o : listaCases) {
      SwitchCaso sc = (SwitchCaso)o;
      vals.add(sc.getExpresion());
    }
    return vals;
  }

  public LinkedList extraerInstrucciones(LinkedList listaCases) {
    LinkedList instrs = new LinkedList();
    if (listaCases == null) return instrs;
    for (Object o : listaCases) {
      SwitchCaso sc = (SwitchCaso)o;
      instrs.add(sc.getInstrucciones());
    }
    return instrs;
  }
:}

// Terminals
terminal VAR, INT, DOUBLE, BOOL, CHAR, STRINGTYPE;
terminal IF, ELSE;
terminal WHILE, FOR, DO;
terminal BREAK, CONTINUE;
terminal PRINT;
terminal String CADENA, ENTERO, DECIMAL;
terminal char CARACTER;
terminal boolean BOOLEANO;
terminal String IDENTIFICADOR;

terminal MAS, MENOS, MULT, DIV, POTENCIA, MODULO;
terminal INCREMENTO, DECREMENTO;
terminal IGUAL, DIFERENTE, MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL;
terminal AND, OR, XOR, NOT;
terminal PAR_ABRIR, PAR_CERRAR;
terminal LLAVE_ABRIR, LLAVE_CERRAR;
terminal PUNTO_COMA, DOS_PUNTOS;
terminal SWITCH, CASE, DEFAULT;
terminal ASIG;
terminal UMINUS;
terminal COMA, START, VOID;
terminal ROUND, TOSTRING;
terminal RETURN;
terminal COR_ABRIR, COR_CERRAR;
terminal APPEND, REMOVE;
terminal LIST, NEW;
terminal PUNTO;
terminal LENGTH, FIND;

// Nonterminals
nonterminal LinkedList INICIO, INSTRUCCIONES, LISTA_CASES, ELSEIF_LIST, DEFAULT_INST;
nonterminal Instruccion INSTRUCCION, EXPRESION, DECLARACION, ASIGNACION, SIF, WHILE_LOOP, DO_WHILE_LOOP, FOR_LOOP, BREAK_INST, CONTINUE_INST, SWITCH_INST;
nonterminal SwitchCaso CASE_INST;
nonterminal Tipo TIPO;
nonterminal LinkedList<HashMap> PARAMS;
nonterminal Instruccion STARTT, LLAMADA;
nonterminal LinkedList<Instruccion> PARAMSLLAMADA;
nonterminal LinkedList<Instruccion> LISTA_EXPR;
nonterminal Instruccion FUNCION_DECL;
nonterminal Instruccion DECLARACIONLISTA;
nonterminal Tipo TIPO_BASE;

precedence left OR;
precedence left AND;
precedence left XOR;
precedence right NOT;
precedence left IGUAL, DIFERENTE, MENOR, MAYOR, MENOR_IGUAL, MAYOR_IGUAL;
precedence left MAS, MENOS;
precedence left MULT, DIV, MODULO;
precedence right POTENCIA;
precedence right UMINUS;
precedence left COR_ABRIR;

start with INICIO;

INICIO ::= INSTRUCCIONES:a {: RESULT = a; :};

INSTRUCCIONES ::= INSTRUCCIONES:a INSTRUCCION:b {: RESULT = a; a.add(b); :}
                | INSTRUCCION:a {: RESULT = new LinkedList(); RESULT.add(a); :};

INSTRUCCION ::= PRINT PAR_ABRIR EXPRESION:a PAR_CERRAR PUNTO_COMA {: RESULT = new Print(a, aleft, aright); :}
              | DECLARACION:a PUNTO_COMA {: RESULT = a; :}
              | DECLARACION:a {: RESULT = a; :}
              | ASIGNACION:a PUNTO_COMA {: RESULT = a; :}
              | ASIGNACION:a {: RESULT = a; :}
              | SIF:a {: RESULT = a; :}
              | WHILE_LOOP:a {: RESULT = a; :}
              | DO_WHILE_LOOP:a {: RESULT = a; :}
              | FOR_LOOP:a {: RESULT = a; :}
              | SWITCH_INST:a {: RESULT = a; :}
              | BREAK_INST:a {: RESULT = a; :}
              | CONTINUE_INST:a {: RESULT = a; :}
              | IDENTIFICADOR:a INCREMENTO {: RESULT = new Incremento(a, true, aleft, aright); :}
              | IDENTIFICADOR:a DECREMENTO {: RESULT = new Incremento(a, false, aleft, aright); :}
              | IDENTIFICADOR:a INCREMENTO PUNTO_COMA {: RESULT = new Incremento(a, true, aleft, aright); :}
              | IDENTIFICADOR:a DECREMENTO PUNTO_COMA {: RESULT = new Incremento(a, false, aleft, aright); :}
              | STARTT:a {: RESULT = a; :}
              | RETURN EXPRESION:a PUNTO_COMA {: RESULT = new Return(a, aleft, aright); :}
              | RETURN PUNTO_COMA             {: RESULT = new Return(null, 0, 0); :}
              | IDENTIFICADOR:a COR_ABRIR EXPRESION:b COR_CERRAR ASIG EXPRESION:c PUNTO_COMA
              {: RESULT = new AsignacionVector(a, b, c, aleft, aright); :}
              | IDENTIFICADOR:a COR_ABRIR EXPRESION:b COR_CERRAR COR_ABRIR EXPRESION:c COR_CERRAR ASIG EXPRESION:d PUNTO_COMA
                {: RESULT = new AsignacionVector2D(a, b, c, d, aleft, aright); :}
              | FUNCION_DECL:a {: RESULT = a; :}
              | LLAMADA:a {: RESULT = a; :}
              | IDENTIFICADOR:a PUNTO APPEND PAR_ABRIR EXPRESION:b PAR_CERRAR PUNTO_COMA
                {: RESULT = new Append(a, b, aleft, aright); :}
              | IDENTIFICADOR:a PUNTO REMOVE PAR_ABRIR EXPRESION:b PAR_CERRAR PUNTO_COMA
                {: RESULT = new Remove(a, b, aleft, aright); :}
              | DECLARACIONLISTA:a {: RESULT = a; :}
              | DECLARACIONLISTA:a PUNTO_COMA {: RESULT = a; :}
              ;

WHILE_LOOP ::= WHILE PAR_ABRIR EXPRESION:a PAR_CERRAR LLAVE_ABRIR INSTRUCCIONES:b LLAVE_CERRAR
               {: RESULT = new While(a, b, aleft, aright); :};

DO_WHILE_LOOP ::= DO LLAVE_ABRIR INSTRUCCIONES:a LLAVE_CERRAR WHILE PAR_ABRIR EXPRESION:b PAR_CERRAR PUNTO_COMA
                  {: RESULT = new Do_While(b, a, new Tipo(Datos.VOID), bleft, bright); :};

FOR_LOOP ::= 
  FOR PAR_ABRIR DECLARACION:a PUNTO_COMA EXPRESION:b PUNTO_COMA INSTRUCCION:c PAR_CERRAR 
    LLAVE_ABRIR INSTRUCCIONES:d LLAVE_CERRAR
    {: RESULT = new For(a, b, c, d, new Tipo(Datos.VOID), aleft, aright); :}
| FOR PAR_ABRIR ASIGNACION:a PUNTO_COMA EXPRESION:b PUNTO_COMA INSTRUCCION:c PAR_CERRAR 
    LLAVE_ABRIR INSTRUCCIONES:d LLAVE_CERRAR
    {: RESULT = new For(a, b, c, d, new Tipo(Datos.VOID), aleft, aright); :};

SIF ::= IF PAR_ABRIR EXPRESION:a PAR_CERRAR LLAVE_ABRIR INSTRUCCIONES:b LLAVE_CERRAR
        {: RESULT = new If(a, b, aleft, aright); :}
      | IF PAR_ABRIR EXPRESION:a PAR_CERRAR LLAVE_ABRIR INSTRUCCIONES:b LLAVE_CERRAR ELSE LLAVE_ABRIR INSTRUCCIONES:c LLAVE_CERRAR
        {: RESULT = new If(a, b, c, aleft, aright); :}
      | IF PAR_ABRIR EXPRESION:a PAR_CERRAR LLAVE_ABRIR INSTRUCCIONES:b LLAVE_CERRAR ELSEIF_LIST:d
        {: RESULT = new If(a, b, d, null, new Tipo(Datos.VOID), aleft, aright); :}
      | IF PAR_ABRIR EXPRESION:a PAR_CERRAR LLAVE_ABRIR INSTRUCCIONES:b LLAVE_CERRAR ELSEIF_LIST:d ELSE LLAVE_ABRIR INSTRUCCIONES:e LLAVE_CERRAR
        {: RESULT = new If(a, b, d, e, new Tipo(Datos.VOID), aleft, aright); :};

ELSEIF_LIST ::= ELSEIF_LIST:a ELSE IF PAR_ABRIR EXPRESION:b PAR_CERRAR LLAVE_ABRIR INSTRUCCIONES:c LLAVE_CERRAR
                {: RESULT = a; a.add(new If(b, c, bleft, bright)); :}
              | ELSE IF PAR_ABRIR EXPRESION:a PAR_CERRAR LLAVE_ABRIR INSTRUCCIONES:b LLAVE_CERRAR
                {: RESULT = new LinkedList(); RESULT.add(new If(a, b, aleft, aright)); :};

BREAK_INST ::= BREAK:b PUNTO_COMA {: RESULT = new Break(bleft, bright); :};

CONTINUE_INST ::= CONTINUE:c PUNTO_COMA {: RESULT = new Continue(cleft, cright); :};

DECLARACION ::=
    VAR IDENTIFICADOR:a DOS_PUNTOS TIPO:t ASIG EXPRESION:e
    {: RESULT = new Declaracion(a, e, t, aleft, aright); :}
  | VAR IDENTIFICADOR:a DOS_PUNTOS TIPO:t
    {: RESULT = new Declaracion(a, null, t, aleft, aright); :}
;


LISTA_CASES ::= LISTA_CASES:a CASE_INST:b {: RESULT = a; a.add(b); :}
              | CASE_INST:a {: RESULT = new LinkedList(); RESULT.add(a); :};
 
CASE_INST ::= CASE EXPRESION:a DOS_PUNTOS INSTRUCCIONES:b 
              {: RESULT = new SwitchCaso(a, b); :};

DEFAULT_INST ::= DEFAULT DOS_PUNTOS INSTRUCCIONES:a {: RESULT = a; :}
               | {: RESULT = null; :};

SWITCH_INST ::= SWITCH PAR_ABRIR EXPRESION:a PAR_CERRAR LLAVE_ABRIR LISTA_CASES:b DEFAULT_INST:c LLAVE_CERRAR
                {: RESULT = new Switch(a, extraerValores(b), extraerInstrucciones(b), c, new Tipo(Datos.VOID), aleft, aright); :}
              | SWITCH PAR_ABRIR EXPRESION:a PAR_CERRAR LLAVE_ABRIR DEFAULT_INST:c LLAVE_CERRAR
                {: RESULT = new Switch(a, new LinkedList(), new LinkedList(), c, new Tipo(Datos.VOID), aleft, aright); :};

ASIGNACION ::= IDENTIFICADOR:a ASIG EXPRESION:b
               {: RESULT = new Asignacion(a, b, aleft, aright); :};

PARAMS ::= PARAMS:a COMA TIPO_BASE:b IDENTIFICADOR:c
           {: 
             RESULT = a;
             var hm2 = new HashMap<String, Object>();
             hm2.put("id", c);
             hm2.put("tipo", b);
             RESULT.add(hm2);
           :}
         | TIPO_BASE:a IDENTIFICADOR:b
           {: 
             RESULT = new LinkedList<HashMap>();
             var hm = new HashMap<String, Object>();
             hm.put("id", b);
             hm.put("tipo", a);  
             RESULT.add(hm);
           :}
;

STARTT ::= START IDENTIFICADOR:a PAR_ABRIR PAR_CERRAR PUNTO_COMA
           {: RESULT = new Start(a, new LinkedList<>(), aleft, aright); :}
         | START IDENTIFICADOR:a PAR_ABRIR PARAMSLLAMADA:b PAR_CERRAR PUNTO_COMA
           {: RESULT = new Start(a, b, aleft, aright); :}
;

PARAMSLLAMADA ::= PARAMSLLAMADA:a COMA EXPRESION:b
                  {: RESULT = a; RESULT.add(b); :}
                | EXPRESION:a
                  {: RESULT = new LinkedList(); RESULT.add(a); :}
;

LLAMADA ::= IDENTIFICADOR:a PAR_ABRIR PARAMSLLAMADA:b PAR_CERRAR PUNTO_COMA
            {: RESULT = new Llamada(a, b, aleft, aright); :}
          | IDENTIFICADOR:a PAR_ABRIR PAR_CERRAR PUNTO_COMA
            {: RESULT = new Llamada(a, new LinkedList<>(), aleft, aright); :}
;

LISTA_EXPR ::= 
    LISTA_EXPR:a COMA EXPRESION:b {: RESULT = a; RESULT.add(b); :}
  | EXPRESION:a {: RESULT = new LinkedList<Instruccion>(); RESULT.add(a); :}
  | {: RESULT = new LinkedList<Instruccion>(); :}
;

FUNCION_DECL ::= 
    TIPO:a IDENTIFICADOR:b PAR_ABRIR PAR_CERRAR LLAVE_ABRIR INSTRUCCIONES:c LLAVE_CERRAR
    {: 
        RESULT = new Funcion(b, new LinkedList<HashMap>(), c, a, bleft, bright);
    :}
    | TIPO:a IDENTIFICADOR:b PAR_ABRIR PARAMS:p PAR_CERRAR LLAVE_ABRIR INSTRUCCIONES:c LLAVE_CERRAR
    {: 
        RESULT = new Funcion(b, p, c, a, bleft, bright);
    :}
;

DECLARACIONLISTA ::= 
    LIST MENOR TIPO_BASE:a MAYOR IDENTIFICADOR:b ASIG NEW LIST PAR_ABRIR PAR_CERRAR
    {: 
        Tipo tipoLista = new Tipo(Datos.LIST, 0, null, a);
        RESULT = new DeclaracionLista(b, tipoLista, aleft, aright); 
    :}
;

TIPO ::= TIPO_BASE:a
         {: RESULT = a; :}
       | TIPO_BASE:a COR_ABRIR COR_CERRAR
         {: RESULT = new Tipo(a.getTipo(), 1); :}
       | TIPO_BASE:a COR_ABRIR COR_CERRAR COR_ABRIR COR_CERRAR
         {: RESULT = new Tipo(a.getTipo(), 2); :}
;

TIPO_BASE ::= INT
              {: RESULT = new Tipo(Datos.ENTERO); :}
            | DOUBLE
              {: RESULT = new Tipo(Datos.DECIMAL); :}
            | BOOL
              {: RESULT = new Tipo(Datos.BOOLEANO); :}
            | CHAR
              {: RESULT = new Tipo(Datos.CARACTER); :}
            | STRINGTYPE
              {: RESULT = new Tipo(Datos.CADENA); :}
            | VOID
              {: RESULT = new Tipo(Datos.VOID); :}
;


// --- EXPRESSIONS ---
EXPRESION ::= 
    // Operadores lógicos
    EXPRESION:a OR EXPRESION:b
        {: RESULT = new Logicas(a, b, OperadoresLogicos.OR, aleft, aright); :}
  | EXPRESION:a AND EXPRESION:b
        {: RESULT = new Logicas(a, b, OperadoresLogicos.AND, aleft, aright); :}
  | EXPRESION:a XOR EXPRESION:b
        {: RESULT = new Logicas(a, b, OperadoresLogicos.XOR, aleft, aright); :}
  | NOT EXPRESION:a
        {: RESULT = new Logicas(null, a, OperadoresLogicos.NOT, aleft, aright); :}

    // Relacionales
  | EXPRESION:a IGUAL EXPRESION:b
        {: RESULT = new Relacionales(a, b, OperadoresRelacionales.IGUAL, aleft, aright); :}
  | EXPRESION:a DIFERENTE EXPRESION:b
        {: RESULT = new Relacionales(a, b, OperadoresRelacionales.DIFERENTE, aleft, aright); :}
  | EXPRESION:a MENOR EXPRESION:b
        {: RESULT = new Relacionales(a, b, OperadoresRelacionales.MENOR, aleft, aright); :}
  | EXPRESION:a MAYOR EXPRESION:b
        {: RESULT = new Relacionales(a, b, OperadoresRelacionales.MAYOR, aleft, aright); :}
  | EXPRESION:a MENOR_IGUAL EXPRESION:b
        {: RESULT = new Relacionales(a, b, OperadoresRelacionales.MENOR_IGUAL, aleft, aright); :}
  | EXPRESION:a MAYOR_IGUAL EXPRESION:b
        {: RESULT = new Relacionales(a, b, OperadoresRelacionales.MAYOR_IGUAL, aleft, aright); :}

    // Aritméticos
  | EXPRESION:a MAS EXPRESION:b
        {: RESULT = new Aritmetica(a, b, OperadoresAritmeticos.SUMA, aleft, aright); :}
  | EXPRESION:a MENOS EXPRESION:b
        {: RESULT = new Aritmetica(a, b, OperadoresAritmeticos.RESTA, aleft, aright); :}
  | EXPRESION:a MULT EXPRESION:b
        {: RESULT = new Aritmetica(a, b, OperadoresAritmeticos.MULTIPLICACION, aleft, aright); :}
  | EXPRESION:a DIV EXPRESION:b
        {: RESULT = new Aritmetica(a, b, OperadoresAritmeticos.DIVISION, aleft, aright); :}
  | EXPRESION:a MODULO EXPRESION:b
        {: RESULT = new Aritmetica(a, b, OperadoresAritmeticos.MODULO, aleft, aright); :}
  | EXPRESION:a POTENCIA EXPRESION:b
        {: RESULT = new Aritmetica(a, b, OperadoresAritmeticos.POTENCIA, aleft, aright); :}
  | MENOS EXPRESION:a
        {: RESULT = new Aritmetica(OperadoresAritmeticos.NEGACION, a, aleft, aright); :} %prec UMINUS

    // Casting y paréntesis
  | PAR_ABRIR TIPO:a PAR_CERRAR EXPRESION:b
        {: RESULT = new Casteo(a.getTipo(), b, aleft, aright); :}
  | PAR_ABRIR EXPRESION:a PAR_CERRAR
        {: RESULT = a; :}

    // Literales
  | ENTERO:a
        {: RESULT = new Nativo(Integer.valueOf(a), new Tipo(Datos.ENTERO), aleft, aright); :}
  | DECIMAL:a
        {: RESULT = new Nativo(Double.valueOf(a), new Tipo(Datos.DECIMAL), aleft, aright); :}
  | CARACTER:a
        {: RESULT = new Nativo(a, new Tipo(Datos.CARACTER), aleft, aright); :}
  | CADENA:a
        {: RESULT = new Nativo(a, new Tipo(Datos.CADENA), aleft, aright); :}
  | BOOLEANO:a
        {: RESULT = new Nativo(a, new Tipo(Datos.BOOLEANO), aleft, aright); :}

    // Identificador simple
  | IDENTIFICADOR:a
        {: RESULT = new AccesoVar(a, aleft, aright); :}

    // Funciones nativas
  | ROUND PAR_ABRIR EXPRESION:a PAR_CERRAR
        {: RESULT = new Round(a, null, aleft, aright); :}
  | TOSTRING PAR_ABRIR EXPRESION:a PAR_CERRAR
        {: RESULT = new ToString(a, null, aleft, aright); :}

    // Acceso a listas/métodos
  | LENGTH PAR_ABRIR EXPRESION:a PAR_CERRAR
    {: RESULT = new Length(a, aleft, aright); :}

  | IDENTIFICADOR:a PUNTO FIND PAR_ABRIR EXPRESION:b PAR_CERRAR
        {: RESULT = new Find(a, b, aleft, aright); :}
  | IDENTIFICADOR:a PUNTO APPEND PAR_ABRIR EXPRESION:b PAR_CERRAR
        {: RESULT = new Append(a, b, aleft, aright); :}
  | IDENTIFICADOR:a PUNTO REMOVE PAR_ABRIR EXPRESION:b PAR_CERRAR
        {: RESULT = new Remove(a, b, aleft, aright); :}

    // ✅ ACCESO A MATRICES: ¡2D ANTES QUE 1D!
  | IDENTIFICADOR:a COR_ABRIR EXPRESION:b COR_CERRAR COR_ABRIR EXPRESION:c COR_CERRAR
    {: RESULT = new AccesoVector2D(a, b, c, aleft, aright); :}

| IDENTIFICADOR:a COR_ABRIR EXPRESION:b COR_CERRAR
    {: RESULT = new AccesoVector(a, b, aleft, aright); :}

    // Inicializador de vector (debe ir al final para no interferir)
  | COR_ABRIR LISTA_EXPR:a COR_CERRAR
        {: RESULT = new InicializadorVector(a, aleft, aright); :}

    // Llamadas a función
  | IDENTIFICADOR:a PAR_ABRIR PAR_CERRAR
        {: RESULT = new Llamada(a, new LinkedList<>(), aleft, aright); :}
  | IDENTIFICADOR:a PAR_ABRIR PARAMSLLAMADA:b PAR_CERRAR
        {: RESULT = new Llamada(a, b, aleft, aright); :}
;